// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
#include "vmlinux.h" // Use quotes for local file generated by bpftool
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h> // Still needed for SEC() macro perhaps, or other types
#include <bpf/bpf_core_read.h>

// Define TASK_COMM_LEN if not found in vmlinux.h (usually 16)
#ifndef TASK_COMM_LEN
#define TASK_COMM_LEN 16
#endif

// Max stack depth to capture
#define MAX_STACK_DEPTH 127 // Keep this consistent with user-space

// Map to store the stack traces (key: stack_id, value: array of addresses)
struct {
    __uint(type, BPF_MAP_TYPE_STACK_TRACE);
    __uint(key_size, sizeof(u32)); // stack_id
    __uint(value_size, MAX_STACK_DEPTH * sizeof(u64)); // Stack addresses
    __uint(max_entries, 10240); // Adjust as needed
} stack_traces SEC(".maps");

// Map to send events (stack_id + pid) to user space
struct event {
    u32 stack_id;
    u32 pid;
};

struct {
    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
    __uint(key_size, sizeof(u32));
    __uint(value_size, sizeof(u32));
} events SEC(".maps");

// Perf event handler (attached to a sampling perf event like CPU cycles or clock)
SEC("perf_event")
// Use a standard function definition instead of BPF_PROG macro
int do_stack_sample(struct bpf_perf_event_data* ctx) {
    u64 id = bpf_get_current_pid_tgid();
    u32 tgid = id >> 32; // Get Process ID (TGID)

    // --- Filtering Logic START ---
    char comm[TASK_COMM_LEN];
    bpf_get_current_comm(&comm, sizeof(comm));

    // --- MODIFIED FILTER ---
    // Check only the first 4 characters for "slow"
    // This is less strict than requiring the null terminator at index 4
    if (!(comm[0] == 's' && comm[1] == 'l' && comm[2] == 'o' && comm[3] == 'w')) {
        return 0; // First 4 chars not "slow", exit early
    }
    // --- Filtering Logic END ---

    // Only sample user-space stacks for the filtered process
    s32 stack_id = bpf_get_stackid(ctx, &stack_traces, BPF_F_USER_STACK);
    if (stack_id < 0) {
        // Error or empty stack
        return 0;
    }

    // Prepare event data to send to user space
    struct event event_data = {};
    event_data.stack_id = (u32)stack_id;
    event_data.pid = tgid; // Send process ID

    // Send data to user space via perf buffer
    bpf_perf_event_output(ctx, &events, BPF_F_CURRENT_CPU, &event_data, sizeof(event_data));

    return 0;
}

char LICENSE[] SEC("license") = "Dual BSD/GPL";